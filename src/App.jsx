import * as THREE from 'three'
import React, { Suspense, useRef, useEffect, useState } from 'react'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import { Html, Environment, useGLTF, ContactShadows, OrbitControls , PerspectiveCamera} from '@react-three/drei'
import HeroPage from './HeroPage'



function Model(props) {
  const [hovered, setHovered] = useState(false)
  const group = useRef()
  const iframeRef=useRef()
  const { camera } = useThree()
  // Load model
  const { nodes, materials } = useGLTF('/mac-draco.glb')
  const orbitref = useRef();
  const [lastTime, setLastTime] = useState(0);
  let initialCameraPosition = new THREE.Vector3(0, 5*1.2, -15*1.2);
  // Make it float

  useFrame((state) => {
    if(hovered){
      camera.position.lerp(new THREE.Vector3(0, 5*0.35, -15*0.35),0.05)
    }
    else{
      if(state.clock.getElapsedTime()-lastTime<=1&&(camera.position.x-initialCameraPosition.x>0.1||camera.position.y-initialCameraPosition.y>0.1||camera.position.z-initialCameraPosition.z>0.1)){
        camera.position.lerp(initialCameraPosition,0.05)
      }
    }
    console.log(camera.position)
    orbitref.current.update()
  })

  useFrame((state) => {
    const iframe = iframeRef.current
    if (!iframe) return
    const handleMouseEnter = () => {
      console.log('Hovered over iframe!')
      setHovered(true)
    }
    const handleMouseLeave = () => {
      console.log('Mouse left iframe!')
      setLastTime(state.clock.getElapsedTime());
      setHovered(false)
    }
    iframe.addEventListener('mouseenter', handleMouseEnter)
    iframe.addEventListener('mouseleave', handleMouseLeave)
  })

  useFrame((state) => {
    const t=state.clock.getElapsedTime()
    if(!hovered){

      // group.current.rotation.x = THREE.MathUtils.lerp(group.current.rotation.x, Math.cos(t / 2) / 20 + 0.25, 0.1)
      // group.current.rotation.y = THREE.MathUtils.lerp(group.current.rotation.y, Math.sin(t / 4) / 20, 0.1)
      // group.current.rotation.z = THREE.MathUtils.lerp(group.current.rotation.z, Math.sin(t / 8) / 20, 0.1)
      group.current.position.y = THREE.MathUtils.lerp(group.current.position.y, (-2 + Math.sin(t / 2)) / 2, 0.1)
      // orbitref.current.saveState()
    }
    else{
      group.current.position.x=THREE.MathUtils.lerp(group.current.position.x, 0, 0.05)
      group.current.position.y=THREE.MathUtils.lerp(group.current.position.y, -3, 0.05)
      group.current.position.z=THREE.MathUtils.lerp(group.current.position.z, 0, 0.05)

    }
    
  })

  // The jsx graph was auto-generated by: https://github.com/pmndrs/gltfjsx
  return (
    <group ref={group} {...props} dispose={null} rotation-x={0.425} position={[0,0,0]}>
      <group rotation-x={-0.505} position={[0, -0.04, 0.41]}>
        <group position={[0, 2.96, -0.13]} rotation={[Math.PI / 2, 0, 0]}>
          <mesh material={materials.aluminium} geometry={nodes['Cube008'].geometry} />
          <mesh material={materials['matte.001']} geometry={nodes['Cube008_1'].geometry} />
          <mesh geometry={nodes['Cube008_2'].geometry}>
            {/* Drei's HTML component can "hide behind" canvas geometry */}
            <Html className="content" rotation-x={-Math.PI / 2} position={[0, 0.05, -0.09]} transform occlude distanceFactor={2.52}>
              <div className="wrapper" onPointerDown={(e) => e.stopPropagation()}>
                <iframe src="https://neodoggy.github.io"
                        ref={iframeRef}
                />
              </div>
            </Html>
            <OrbitControls enablePan={false} enableZoom={true} minPolarAngle={Math.PI / 2.2} maxPolarAngle={Math.PI / 2.2} ref={orbitref}/>
          </mesh>
        </group>
      </group>
      <mesh material={materials.keys} geometry={nodes.keyboard.geometry} position={[1.79, 0, 3.45]} />
      <group position={[0, -0.1, 3.39]}>
        <mesh material={materials.aluminium} geometry={nodes['Cube002'].geometry} />
        <mesh material={materials.trackpad} geometry={nodes['Cube002_1'].geometry} />
      </group>
      <mesh material={materials.touchbar} geometry={nodes.touchbar.geometry} position={[0, -0.03, 1.2]} />
    </group>
    
  )
}

export default function App() {
  return (
    <Canvas camera={{ position: [0, 5*1.2, -15*1.2], fov: 55 }}>
      {/* <axesHelper args={[5]} /> */}
      <pointLight position={[10, 10, 10]} intensity={1.5} />
      <Suspense fallback={null}>
        <group rotation={[0, Math.PI, 0]} position={[0, 0, 0]}>
          <Model />
        </group>
        <Environment preset="city" />
      </Suspense>
      <ContactShadows position={[0, -7.5, 0]} scale={20} blur={2} far={7.5} />
    </Canvas>
  )
}
