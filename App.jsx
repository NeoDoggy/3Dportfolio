import * as THREE from 'three'
import React, { Suspense, useRef, useEffect, useState } from 'react'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import { Html, Environment, useGLTF, ContactShadows, OrbitControls , PerspectiveCamera} from '@react-three/drei'
import HeroPage from './HeroPage'



function Model({props,orbitref}) {
  const [hovered, setHovered] = useState(false)
  const group = useRef()
  const iframeRef=useRef()
  const { camera } = useThree()
  // Load model
  const { nodes, materials } = useGLTF('/mac-draco.glb')
  // const orbitref = useRef();
  const [orINIT, setOI] = useState(true);
  let initialCameraPosition = new THREE.Vector3(0, 5*1.2, -15*1.2);
  // Make it float

  useFrame((state) => {
    if(hovered){
      camera.position.lerp(new THREE.Vector3(0, 5*0.35, -15*0.35),0.05)
      orbitref.current.target.lerp(new THREE.Vector3(0, 3, 0),0.05)
      setOI(false)
    }
    else{
      if(orINIT==false&&(Math.abs(camera.position.x-initialCameraPosition.x)>3||Math.abs(camera.position.y-initialCameraPosition.y)>4||Math.abs(camera.position.z-initialCameraPosition.z)>3)){
        orbitref.current.target.lerp(new THREE.Vector3(0, 0, 0),0.05)
        camera.position.lerp(initialCameraPosition,0.05)
      }
      else{
        setOI(true)
      }
    }
    // console.log(Math.abs(camera.position.x-initialCameraPosition.x))
    // console.log(Math.abs(camera.position.y-initialCameraPosition.y))
    // console.log(Math.abs(camera.position.z-initialCameraPosition.z))
    orbitref.current.update()
  })

  useFrame(() => {
    const iframe = iframeRef.current
    if (!iframe) return
    const handleMouseEnter = () => {
      console.log('Hovered over iframe!')
      setHovered(true)
    }
    const handleMouseLeave = () => {
      console.log('Mouse left iframe!')
      // setLastTime(state.clock.getElapsedTime());
      setHovered(false)
    }
    iframe.addEventListener('mouseenter', handleMouseEnter)
    iframe.addEventListener('mouseleave', handleMouseLeave)
  })

  useFrame((state) => {
    const t=state.clock.getElapsedTime()
    if(!hovered){

      // group.current.rotation.x = THREE.MathUtils.lerp(group.current.rotation.x, Math.cos(t / 2) / 20 + 0.25, 0.1)
      // group.current.rotation.y = THREE.MathUtils.lerp(group.current.rotation.y, Math.sin(t / 4) / 20, 0.1)
      // group.current.rotation.z = THREE.MathUtils.lerp(group.current.rotation.z, Math.sin(t / 8) / 20, 0.1)
      // group.current.position.y = THREE.MathUtils.lerp(group.current.position.y, (-2 + Math.sin(t / 2)) / 2, 0.1)
      // orbitref.current.saveState()
    }
    else{
      // group.current.position.x=THREE.MathUtils.lerp(group.current.position.x, 0, 0.05)
      // group.current.position.y=THREE.MathUtils.lerp(group.current.position.y, -3, 0.05)
      // group.current.position.z=THREE.MathUtils.lerp(group.current.position.z, 0, 0.05)

    }
    
  })

  // The jsx graph was auto-generated by: https://github.com/pmndrs/gltfjsx
  return (
    <>
    <group ref={group} {...props} dispose={null} rotation-x={0.425} position={[0, 0, 0]}>
        <group rotation-x={-0.505} position={[0, -0.04, 0.41]}>
          <group position={[0, 2.96, -0.13]} rotation={[Math.PI / 2, 0, 0]}>
            <mesh material={materials.aluminium} geometry={nodes['Cube008'].geometry} />
            <mesh material={materials['matte.001']} geometry={nodes['Cube008_1'].geometry}>
            <mesh material={materials['matte.001']} geometry={nodes['Cube008_2'].geometry}>
              {/* Drei's HTML component can "hide behind" canvas geometry */}
              <Html className="content" rotation-x={-Math.PI / 2} position={[0, 0.05, -0.09]} transform occlude distanceFactor={2.52}>
                <div className="wrapper" onPointerDown={(e) => e.stopPropagation()}>
                  <iframe src="https://neodoggy.github.io"
                    ref={iframeRef} />
                </div>
              </Html>
              
            </mesh>
            </mesh>
          </group>
        </group>
        <mesh material={materials.keys} geometry={nodes.keyboard.geometry} position={[1.79, 0, 3.45]} />
        <group position={[0, -0.1, 3.39]}>
          <mesh material={materials.aluminium} geometry={nodes['Cube002'].geometry} />
          <mesh material={materials.trackpad} geometry={nodes['Cube002_1'].geometry} />
        </group>
        <mesh material={materials.touchbar} geometry={nodes.touchbar.geometry} position={[0, -0.03, 1.2]} />
      </group>
      <ContactShadows position={[0, -3.9, 0]} scale={20} blur={2} far={7.5} />
      <mesh material={materials.keys} position={[0,-4,0]}>
        <boxGeometry attach="geometry" args={[20,0.05,20]}/>
      </mesh>
    </>
    
  )
}

export default function App() {
  const orbitref=useRef()
  return (
    <>
      <div style={{margin:"50px", position:"absolute", zIndex:"9999999"}}>
        Hello world
      </div>
      
    <Canvas camera={{ position: [0, 5 * 1.2, -15 * 1.2], fov: 55 }}>
      {/* <axesHelper args={[5]} /> */}
      <pointLight position={[10, 10, 10]} intensity={1.5} />
      <Suspense fallback={null}>
        <group rotation={[0, Math.PI, 0]} position={[0, 0, 0]}>
          <Model orbitref={orbitref}/>
        </group>
        <Environment preset="warehouse" />
      </Suspense>
      <ContactShadows position={[0, -10.5, 0]} scale={40} blur={2} far={11} />
      <OrbitControls enablePan={false} enableZoom={true} minPolarAngle={Math.PI / 2.2} maxPolarAngle={Math.PI / 2.2} ref={orbitref} />
    </Canvas>
    </>
  )
}
